\documentclass[11pt,a4paper,oneside]{article}
\renewcommand*\thesection{\arabic{section}}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\usepackage{tocloft}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage{array}
\usepackage{rotating}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{epstopdf}
\usepackage{subfig}
\usepackage{txfonts}
\usepackage{url}
\usepackage{graphics}
\usepackage[titletoc,toc,title]{appendix}
\usepackage{varioref}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{color}
\usepackage{acronym}
\usepackage{url}
\usepackage{caption}
%\usepackage{subcaption}
\usepackage{fancyhdr}
%\usepackage[table]{xcolor}
\usepackage{hhline}


\usepackage[usenames,dvipsnames,table]{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=R,                     % the language of the code
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},      % keyword style
  commentstyle=\color{dkgreen},   % comment style
  stringstyle=\color{mauve},      % string literal style
  escapeinside={\%*}{*)},         % if you want to add a comment within your code
  morekeywords={*,...}            % if you want to add more keywords to the set
} 
\newcommand{\degree}{\ensuremath{^\circ}}
\renewcommand{\headrulewidth}{0pt} % remove the header rule
\newcommand{\includecode}[2][c]{\lstinputlisting[caption=#2, escapechar=, style=custom#1]{#2}}
 
\addtolength{\voffset}{-1.5cm}
\addtolength{\hoffset}{-1.3cm}
\addtolength{\textwidth}{3cm}
\addtolength{\textheight}{120pt}
\addtolength{\marginparwidth}{-100pt}
\addtolength{\oddsidemargin}{-0.3in}
\addtolength{\evensidemargin}{-0.3in}
\textwidth 6.6in
 
\setlength\cftparskip{1pt}
\setlength{\parindent}{0pt}
% leftmark shows the chapter, rightmark shows the section.
\fancyhead{}
\fancyfoot[L]{}% empty left
\fancyfoot[R]{ % right
}
\pagestyle{fancy}

\title {Interim Report - Investigation into the Precise Time Protocol}
\author {James Cox
\\ Department of Electrical and Electronic Engineering \\
\\
University of Bath}
\date{\today}
\begin{document}

\maketitle
\vfill
\newpage
\tableofcontents
\newpage
\begin{abstract}
The ability to synchronise clocks accurately across a network is important in several industries. This report outlines the initial work into the investigation in \acf{PTP}. 
Discussion on some reports have been made as well as the work completed so far on implementing the packet metrics.
Finally the report explains what work will be completed next, and also highlights possible risks and mitigation strategies. 
\end{abstract}
\section*{Acronyms}
\begin{acronym}
\acro{CSMA/CD}{Carrier Sense Multiple Access with Collision Detection}
\acro{GM}{Grandmaster}
\acro{GPS}{Global Positioning System}
\acro{IEEE}{Institute of Electrical and Electronic Engineers}
\acro{LAN}{Local Area Network}
\acro{NERC}{North American Electric Reliability Company}
\acro{NTP}{Network Time Protocol}
\acro{PPS}{Pulse per Second}
\acro{PTP}{Precision Time Protocol}
\acro{PTPd}{PTP Daemon}
\acro{SNTP}{Simple Network Time Protocol}
\acro{UTC}{Coordinated Universal Time}

\end{acronym}
\newpage
\section{Executive Summary}
\section{Introduction}

Synchronising time amongst a number of devices is very important in a wide range of applications.
This can either be for implicit time keeping where timing is not referring to a physical clock, but rather on the order of a set of processes to occur.
Explicit timing is where the exact time is required, for example in a communications system.
The problem is that not every clock can be exactly correct, or it may not be financially feasible to install a very stable and accurate atomic clock in a particular system.\\

Note that there are two types of clock inaccuracy when trying to synchronise clocks. 
Firstly they may have initially started at a different time to the others, therefore there is an offset that needs to be corrected.
This is called offset correction.
The second effect that is noticed is that clocks do not necessarily run at exactly the same speed.
Therefore clocks need to be consistently adjusted, which is called drift correction.
Some clock inaccuracy may be tolerable in some circumstances, but in a number of cases a system must be set up to correct for this instability.\\

There are several industries that would benefit from an accurate timing network. 
Descriptions of some of the industries are shown below.

\begin{description}
\item[Automation Industry] \hfill \\ Processes will need to be synchronised exactly, and can only be if their clocks are in sync with one another.
If clocks are in sync then processes can be separated away from communication between each machine and the processing of the control commands \cite{IEEEApplications}. 
\item[Power Transmission] \hfill \\ Time synchronisation is very important in the power transmission industry, case in point in the North American blackout in August 2003 \cite{PTPFuturePower}. 
It made it difficult for the investigation team to be able to sort through the data received when the timestamps were gathered from an inaccurate clock. 
From the events of this blackout a regulation was put in place to define a minimum absolute accuracy for timestamped data.
The adoption of \ac{NERC}  Standard PRC018\-1 in 2006 \cite{NERCPRC0181} made this law for any recorded substation data in the USA. This requires that timestamped data must be accurate to within 2ms in relation to UTC. % Mention Doble?
\item[Telecommunications] \hfill\\ In telecommunications, timing protocols are being considered when networks need to be synchronised or if mobile base stations need synchronisation pulses.
Plus, with the increase in \ac{GPS} jamming, systems such as 4G must reply on other timing methods incase \ac{GPS} is affected. 
\end{description}

\subsection{Existing Technology}

There are currently a few technologies that will deliver time synchronisation to the above industry, such as: \ac{NTP}, \ac{SNTP}, synchronisation from \ac{GPS} satellites, or \ac{PPS} signals on a separate channel.

\begin{description}
\item[\ac{NTP}] \hfill \\ This is a technology originally designed in 1985 that is used to synchronise clocks over a packet switched network. 
It is able to achieve synchronisation with \ac{UTC} within a few milliseconds, but can maintain sub-millisecond accuracy on a \ac{LAN} if ideal conditions are met. 
Errors due to different packet routes or network congestion can decrease this accuracy by 100ms or more \cite{NTPWhitePaper}.\\

\ac{NTP} uses a client-server hierarchy split into "stratums". 
Figure \ref{fig:NTPHierarchy} below shows the stratums numbered from 0 to 3. 

\begin{figure}[H]
\centering
\includegraphics[scale = 0.5]{./Figures/NTPDiagram.eps}
\caption{\ac{NTP} Network Hierarchy \cite{figRef:NTPHierarchy}}
\label{fig:NTPHierarchy}
\end{figure}

The reference clocks which are in stratum 0 are high precision. 
Examples of such type clocks are atomic or \ac{GPS}. 
The clocks in stratum 2 will base their time off of the clocks in stratum 1. 
A subset of the clocks in stratum 1 will be used so the overall time is more accurate and robust. 
Within a stratum clocks may also synchronise for sanity checkup. 
Any layers below stratum 2 will mirror the same algorithm, and there can be up to 15 layers. 
Stratum 16 is reserved for clocks that are not synchronised with \ac{NTP}.\\ 

\ac{SNTP} is a similar protocol but it is complex than NTP as it does not store the state over long periods of time. 
This is usually used in applications which do not require a high timing accuracy.
The \ac{SNTP} specification can be found in the \ac{NTP} spec, cited here.  \cite{NTPV4Specification}
\item[\ac{GPS} Synchronisation] \hfill \\ Time synchronisation can be performed using the high precision clocks found on \ac{GPS} satellites. 
Even though this provides a high precision synchronisation, the extra cost and effort may restrict its use to only certain circumstances. \cite{IEEEPastSolutions}
\end{description}
%Ask watson about any other methods of timing

The problem occurs if synchronisation across a packet network is needed but sub-millisecond accuracy is desired. 
Therefore \ac{PTP} was developed as a successor to the existing \ac{NTP} standard. 
Meeting this value of accuracy is very difficult however with a traditional Ethernet network. \\

When standard switches are used, the packet delay between two nodes is indeterminate. 
This may be because the packet route from A to B changes depending on network load, or a packet may be held in a switch for an unspecified amount of time whilst working with other data on the network. 
Therefore this is undesired for \ac{PTP} when this packet delay must be taken into account when working out the clock offset. 
Specific timing switches can be used which will prioritise \ac{PTP} packets, but these may not be available in existing networks or be too expensive to be suitable. 

\subsection{Current Technology - PTP}
\subsubsection{Comparison with NTP}
\acf{PTP} was developed in 2003 as Version 1 with the intention to build on the existing \ac{NTP} standard. 
The Version 1 improvement improved on \ac{NTP} in a number of different ways.
A new \ac{PTP} standard was introduced in 2008 which again improved on Version 1 with some new features such as boundary clocks. 
These changes have been  tabulated below, Table \ref{table:NTPPTP}.

\begin{table}[H]
\centering
\caption{NTP Vs PTP Version 1 Vs PTP Version 2}
\begin{tabular}{ |p{4cm} ||p{5cm} |p{5cm} | p{5cm}| }\hline
\cellcolor{Black}\textcolor{White}{\textbf{ Feature }}  &  \cellcolor{Black}\textcolor{White}{\textbf{ \ac{PTP} V2 (IEEE1588-2008) }} & \cellcolor{Black}\textcolor{White}{\textbf{\ac{PTP} V1 (IEEE1588-2002)}} \\ \hline
Transparent Clocks  &  Yes  &  No\\ \hline
Unicast  &  Yes  &  No \\ \hline
Domains  &  Domain Numbers  &  Subdomain Name Fields\\ \hline
Clock Quality & Clock Accuracy / Clock Class & Data Field Stratum \\ \hline
Selection Algorithm for best clock & Hierarchical & Selection based \\ \hline
\multirow{4}{*}{Other Features} & Alternate Time Scale & \\ 
 & Grandmaster Cluster & \\ 
 & Unicast Masters & None\\ 
 & Alternate Master & \\ 
 & Path Trace & \\ \hline
\label{table:NTPPTP}
\end{tabular}
\end{table}

\subsubsection{Brief Description of PTP}

\ac{PTP} uses a similar Master-Slave hierarchy of \ac{NTP}, but it doesn't use the stratum method. Instead it uses domains which seperate out \ac{PTP} synchronisation networks. 
The master clock for the domain will broadcast out the current time to all of the other clocks on the network using a multicast message.
In IEEE1558-2008 this can occur up to one message every 100 milliseconds. \\

\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{./Figures/DelayPTP.eps}
\label{fig:PTPTiming}
\caption{PTP Timing Diagram \cite{PTPTiming}}
\end{figure}

The basic steps that the protocol take are the following:

\begin{enumerate}
\item Broadcast begins at T\textsubscript{1} where the master sends a \textit{sync} to all clocks on the domain.
\item Each slave clock takes a note of when the message was received using their local clock. This is called Time T\textsubscript{1}\testsuperscript{'}.
\item An optional \textit{follow\_up} message may be sent that includes an accurate timestamp of T\textsubscript{1}. This step occurs if the master clock does not have the capability to be able to create an accurate timestamp when sending the \textit{sync} message.
\item In order for the slave to synchronise with the master, the round trip delay needs to be known. Therefore a \textit{delay\_req} message is sent bby the slave clock at Time T\textsubscript{2}. 
\item The master will respond to this message with a \textit{delay\_res} message. 
\end{enumerate}

At this point T\subscript{1}, T\subscript{1}\superscript{'}, T\subscript{2} and T\subscript{2}\superscript{'} are now known. \\

If we define $d$ as the transit time, and \widetilde{o} as the constant offset between the two clocks: 

\begin{equation}
\label{eqn:T1Delay}
T_{1}^{'} - T_{2} = \widetilde{o} + d
\end{equation}

\begin{equation}
\label{eqn:T2Delay}
T_{2}^{'} - T_{2} = - \widetilde{o} + d
\end{equation}

If we rearrage \eqref{eqn:T2Delay} for $d$ : 

\begin{equation}
\label{eqn:3}
d = T_{2}^{'}
\end{equation}

Substituting \eqref{eqn:3} into \eqref{eqn:T1Delay}: 

\begin{equation}
\label{eqn:final}

T_{1}^{'} - T_{1} = \widetilde{o} + T_{2}^{'} - T_{2} + \widetilde{o}
T_{1}^{'} - T_{1} -  T_{2}^{'} +  T_{2} = 2\widetilde{o}
\widetilde{o} = \frac{T_{1}^{'} - T_{1} -  T_{2}^{'} +  T_{2}}{2}
\end{equation}

The offset is now known and can be adjusted for. 
Note however that there are some assumptions in this calculation.
These are:

\begin{enumerate}
\item message exchange is over such a short period of time that the delay is assumed to be constant
\item transit time is symmetrical (i.e. time from Master to Slave is the same as Slave to Master)
\item both the slave and the master can measure the transmit and receive times of messages accurately (ignoring clock drift)
\end{enumerate}


\section{Literature Review}
During the first week of the project a number of different \ac{IEEE} reports were read and summarised in the logbook. 
The reports were:

\begin{description}
\item[IEEE1588-2008 Specification \cite{IEEE1558}] The 2008 specification for \ac{PTP}. This was only used as a reference
\item[Definitions and terminology for synchronization in packet networks \cite{ITUPacketMetrics}] A standard regarding different packet metrics that could be used in order to try and quantify network delay. 
\item[Prevention of Packet Collisions \cite{IEEECollision}] A journal article describing an algorithm that aims to prevent packet collisions in an Ethernet network.
\item[Sub-nanosecond synchronisation \cite{IEEEWhiteRabbit}] A conference paper describing a method of nanosecond accuracy synchonisation
\end{description}
\subsection{Definitions and Terminology for Synchronisation in Packet Networks \cite{ITUPacketMetrics}}
\label{metricReview}

Thi report defines a number of definitions and terms when dealing with Packet Synchronisation, but the section of interest for this report was Appendix I3 and I4.  
These can be split into 3 sections: Packet Selection Methods, Packet Metrics without Pre-filtering and Packet Metrics with Pre-filtering.

\subsubsection{Packet Selection Methods}

There are two main methods of selecting packets: either using a selection technique at the same time as the packet metric calculation, or as a pre-processing technique. \\

Packet selection, when integrated with the calculation, is very useful when the behaviour of a network is wanting to be determined with respect to its packet delay variation. 
This is because it provides a generic method that is independent to a particular slave clock implementation \cite {ITUPacketMetrics}.
This packet selection method is also known as a Class B metric. \\

The other method is using a pre-processing technique which preselects packets from some time window. 
By doing this the process will average out any inconsistencies in the delays, thus resembling a clock running in steady state. 
Therefore this method is more suitable when trying to specify network limits (Class A metric). \\


There are four examples of packet selection methods that are mentioned in the recommendation report. 
These are: Minimum Packet Selection Method, Percentile Packet Selection Method, Band Packet Selection Method and Cluster Range Packet Selection Method. 
These will be discussed in turn and will be implemented.
Implementation details are discussed later in the report.
\subsubsection{Packet Metrics without Pre-filtering}

The first packet method technique discussed is \ac{TDEV}. It is used to specify network wander limits for timing signals. 
It is also applicable to packet data.
\ac{TDEV} can be applied to both integrated and pre-processed packet selection methods. \\

Instead of discussing each of these metrics in detail, the data will be tabulated.
\begin{comment}
\begin{table}[H]
\centering
\caption{Differences in Packet Metrics}
\begin{tabular}{ |p{4cm} ||p{4cm} |p{4cm} | p{4cm}| }\hline
\cellcolor{Black}\textcolor{White}{\textbf{Criteria}}  & \multicol \cellcolor{Black}\textcolor{White}{\textbf{ \ac{PTP} V2 (IEEE1588-2008) }} & \cellcolor{Black}\textcolor{White}{\textbf{\ac{PTP} V1 (IEEE1588-2002)}} \\ \hline
Transparent Clocks  &  Yes  &  No\\ \hline
Unicast  &  Yes  &  No \\ \hline
Domains  &  Domain Numbers  &  Subdomain Name Fields\\ \hline
Clock Quality & Clock Accuracy / Clock Class & Data Field Stratum \\ \hline
Selection Algorithm for best clock & Hierarchical & Selection based \\ \hline
\multirow{5}{*}{Other Features} & Alternate Time Scale & \\ 
 & Grandmaster Cluster & \\ 
 & Unicast Masters & None\\ 
 & Alternate Master & \\ 
 & Path Trace & \\ \hline
\label{table:NTPPTP}
\end{tabular}
\end{Comment}

The implementation equations are quoted in the reference. The approximation equations were used when implementing the functions. 
\subsubsection{Packet Metrics with Pre-filtering}

\subsection{Project Description}
As it can be seen from above, any industry where accurate timing would benefit from PTP, thus determining PTP performance across an network would be useful. 
Also that the basic operation of \ac{PTP} relies on the symmetrical transit times which might not be true in the case of packet switched Ethernet Networks. 
Therefore this project will investigate PTP performance across an existing Ethernet network. 
The project specification has been left intentionally open so other work can be carried out time permitting. 
The university network will be used for this project. \\

The project will aim to quantify the performance of a \ac{PTP} system situated on a heavily used Ethernet network. 
Different packet metrics will be considered when doing this. 
Other work which may be considered to carry out includes (but not limited to): Hardware Slave Clock, Security of a \ac{PTP} Network, or  \ac{PTP} Simulation. 

\subsection{Deliverables}
The following deliverables have been identified:

\begin{description}
\item [Interim Report] A report due at the end of the third week. 
Will contain mainly information about what the project is about, what work has currently been completed, and what further work will be done. 
There is also a section on risks and challenges to the project. 
\item [Log Book] This is a continuous log book of work kept throughout the project. 
It has been used as both a place to document the work completed as well as a notebook of things to remember for the next day.
This is due at the same time as the final year report.
\item [Packet Metric Scripts] This is a deliverable internally for the project.
It is important that these are completed in time for the data collection and analysing to commence. 
\item [Final Year Report] Report which details all of the work completed throughout the project
\item[Poster] A poster to summarise work completed.
Plots are preferred over tables at this stage. 
\end{description}

One other deliverable which may be completed is some TimePort documentation. 
\subsection{Aims and Objectives}

The project can be split into a number of sub goals and objectives. 
The following goals have been identified:
\begin{description}
\item[Learn about \ac{PTP} and other work in relation to the protocol] \hfill \\ 
This stage would occur at the beginning of the project to understand how \ac{PTP} works.
This is important so work can then be carried out to investigate \ac{PTP} performance.
\item[Collect PTP Data] \hfill \\ 
In tandem with the above PTP data can be collected. 
This will be monitoring the performance of \ac{PTP} across the network as well as how using multiple types of grandmaster/slaves affect the performance. 
Different clock locations in the network will also be considered.
\item[Implement some packet metric scripts] \hfill \\ 
To be able to understand the performance of the network, some packet metric scripts will be created. 
A suitable language will be chosen once this part of the project begins.
\item[Determine packet performance using these scripts] \hfill \\
Multiple window sizes and types of metric will be used to quantify network performance.
\item[Test Chronos' equipment and provide feedback] \hfill \\ 
As Chronos has provided this project with some equipment, this equipment will also be thoroughly tested and any information gathered can be passed to them once the project is completed.
\end{description}

Based on the goals above and taking into account the deliverables that need to be met for the Individual Design Project, the overall list of tasks is shown below in no particular order

\begin{itemize}
\item Research and Learn about \ac{PTP}
\item List all available equipment available
\item Set up a small \ac{PTP} network with one Grandmaster and one Slave clock. Start collecting Data
\item Research into different packet metrics that may be used
\item Implement these packet metrics in a suitable programming language
\item Run these packet metrics with the collected data
\item Set a number of slave clocks up throughout the network and run the same packet metric scripts on them.
\item Attempt to quantify \ac{PTP} performance based on these metrics.
\item Interim Report
\item Final Year Report 
\item Poster
\end{itemize}

These tasks have been converted into a Gantt chart which can be found in Figure \ref{fig:GanttChart}. 
\begin{figure}[H]
\centering
\includegraphics[scale = 0.6]{./Figures/GanttChart.eps}
\caption{Gantt Chart for Individual Project}
\label{fig:GanttChart}
\end{figure}

The timescales are only estimates, and thus there are some challenges involved if there are delays in any one of these areas. 
These challenges have been discussed later on in this report.

\section{Work Carried out so Far}

This section outlines all of the work that has been carried out up until now, as well as any results that have been gathered.\\

Once the research phase of the project was completed (middle to end of Week 1), work began in implementing some of the packet metric equations that were read in ITU-T G.8260 \cite{ITUPacketMetrics}. 
The Chronos Grandmaster and Slave clocks were also worked on in the first few weeks trying to get them to create a PTP network. 

\subsection{Packet Metrics}

The ITU recommendation document was thoroughly read through and the packet metrics described in that report were implemented. 
It was decided early on that most, if not all of the packet metrics mentioned in the report would be implemented, and they can then be compared against each other. \\

The first decision that had to be made was what suitable programming language would be picked for the project. 
The most suitable language would have to meet the requirements for this section of the project.
The following requirements were identified:
\begin{itemize}
\item Suitable for reading data, processing the data, and plotting without use of many third party libraries
\item Well documented
\item Reasonably fast with large data sets
\end{itemize}

With the above taken into consideration, the decision was to use R. 
This was primarily because there were other scripts part of \ac{PTPd} that were written in R, but it was also noted to be a language that would be useful to learn.\\

Once the language was chosen, the scripts were written based on the approximated equations found earlier in Section \ref{metricReview}.

Note that git has been used as a version control system for all of these scripts. 
Both reports written in LaTeX and any scripts created have been version controlled. 
At time of writing, the following metrics have been written:

\begin{enumerate}
\item \ac{TDEV}
\item minTDEV
\item bandTDEV
\item percentile TDEV
\end{enumerate}

There are other metrics such as cluster TDEV that were looked in to, but the implementation of these will be completed once better understanding of them has been made. 
This may result in a meeting with some of the engineers in Chronos to discuss these metrics.

\subsubsection{General Form}

Referring to Equation \ref{eqn:GeneralForm}, this can be implemented in two nested for loops. 
The quotient can be performed seperately. 
The function will then return the result. \\


Before the operation can be performed, the window side length needs to be determined. 
This is to ensure that when the  operation is performed the current index value will be the centre of the mask. 
The diagram below shows this more clearly in Figure \ref{fig:windowSide}.

\begin{figure}
\centering
\includegraphics[scale=0.5]{Figures/Window.eps}
\caption{Description of Window and WindowSide}
\label{fig:windowSide}
\end{figure}

The full source code for each script will be in the appendix, but any relevant differences will be added to the main body of the report. 
\subsubsection{TDEV}

Because different sample sets can be used, the following input parameters to the function will be: To, n, N and x, with x being the dataset. The full source code can be found in Appendix \ref{app:TDEV}. \\

The section of code which is different with TDEV is the section of code in the inner loop. 
This performs a mean on the three terms. 
This is shown in Listing \ref{code:TDEV}.
\begin{lstlisting}[caption = TDEV Step]
interimStep <- interimStep + mean(x[(i + (2*n)) - windowSide:(i + (2*n)) + windowSide]) - 2* mean(x[i+n - windowSide : i + n + windowSide]) + mean(x[i - windowSide : i + windowSide])
\end{lstlisting}

This is the inner section of Equation \ref{eq:TDEV} written in R. 

\subsubsection{minTDEV}

The minTDEV script is very similar to TDEV, but the difference is within the main loop. 
Instead of calculating the mean of each window the minimum value is taken. 
The code extract below shows the change. Appendix \ref{app:minTDEV} is the full TDEV source code. 

\begin{lstlisting}[caption = minTDEV step]
interimStep <- interimStep + min(x[(i + (2*n)) - windowSide:(i + (2*n)) + windowSide]) - 2* min(x[i+n - windowSide : i + n + windowSide]) + min(x[i - windowSide : i + windowSide])
\end{lstlisting}


\subsubsection{bandTDEV}

The bandTDEV is based off of the TDEV mentioned previously, but it uses a mean ver a particular band (from a to b) instead of a mean of the entire window. 
Because a bandMean function was not built in to R, one was created in a seperate source file.
This enabled the function to be used in a number of the scripts if required.
The bandMean function will not be explicitly discussed, but the full source is shown in Appendix \ref{app:bandMean}. \\

The full bandTDEV source code can be found in Appendix \ref{app:bandTDEV}, with the one line difference shown below. \\

\begin{lstlisting}[caption = bandTDEV Step]
interimStep <- interimStep + bandMean(x[i + 2*n - windowStep : i + 2*n + windowStep],a,b) - 2 * bandMean(x[i+n - windowStep : i + n + windowStep],a,b) + bandMean(x[i - windowStep : i + windowStep],a,b) 
\end{lstlisting}


\subsubsection{percentileTDEV}

The percentileTDEV function is based very similar to be bandTDEV, except that the lower bad (a) is set to 0. 
Therefore the code itself is very similar for both metrics. 
A seperate source file has been created for ease of source code management, but these will be consolidated at a later date.

\subsubsection{Overall Script}

As multiple metrics will be run on the same source, an overarching script was created to handle the following operations:

\begin{itemize}
\item Takes in a text file input of the data sent from \ac{PTPd}
\item Converts this data into a suitable form if necessary
\item Calls the relevant packet metric functions
\item Displays the data in a suitable form (plot and/or CSV output)
\item Handles user input from the command line
\end{itemize}

The full script can be found in Appendix \ref{app:PacketMetric}. 
All of the functionality above has not been added in to the script, but will be completed in the near future.

\subsection{Packet Metric Results}

Once the scripts were created, some results were gathered. The data gathering is discussed briefly in a later part of this report. \\

The dataset available was a 1.2GB file between the Chronos TimePort \cite{dataSheetTimePort} and a software slave. 
The locations in the network of these clocks were unknown, but most likely it would have been within the EEE department. 
Any data collected from now onwards will be marked correctly.\\

The scripts were initially run with the full dataset, but it was quickly realised that the script takes a very long length of time to run in its current state.
Therefore a subset of the data was created using the Linux command head. 
A set of data files were then created, ranging from 50 data points to the maximum. \\

Note that even though 50 lines of data were collected, the first 4 were truncated.
This was to get rid of the headers, two initialisation lines, and a null value. \\

The plot below (Figure \ref{fig:TDEVminTDEV496}) shows the Packet Metric results using the script in Appendix \ref{app:PacketMetric}. 
This was used to generate a TDEV and minTDEV for the first 496 data points. 

\begin{figure}
\centering
\includegraphics[scale=0.6]{./Figures/plotTDEVminTDEV500.eps}
\caption{Plot of TDEV and minTDEV for a sample size of 496}
\label{fig:TDEVminTDEV496}
\end{figure}

The raw data output in a tabular form is found in Appendix \ref{app:table500Sample}. \\

In its current state a lot more data is required to make some sense of these results. 
The scripts will be amended such that they run much faster (by performing the operation incrementally rather than the total operation on every point), and more data will be collected.\\

The data was also processed briefly by scanning through the data and noticing if there are any sudden changes or fluctuations of delay.
With the initial set of data (not included in this reprt due to it being a large data set), it seems as though the delay is fairly static across the timeframe looked at. 
This is unusual considering that standard switches are used rather specific timing switches. More investigation into why this is the case and how the packet metrics described will affect this outcome. 


\subsection{Chronos Clocks}

For this project there are a number of different bits of equipment that can be used for \ac{PTP} timing. 
A few days in week 1 were spent working with the Grandmaster TimePort clock from Chronos to see how it worked and what functionality it had.
Unfortunately the clock was not able to start the ptp-console during week 2, so more \ac{PTP} data was not able to be gathered.
Chronos will be contacted about this fault and it will be looked into. 

\subsection{PTP Data Collection}

The only data gathered has been from much earlier in Semester 1 and was provided by Dr Robert Watson.
It is unknown under what conditions this data was gathered in (ie clock locations on the network) but it provides a suitable basis in which the packet metric scripts can be tested against.\\

It is expected that a lot more data will be collected during the project.
\section{Challenges}

The challenges have been split into the two main sections of the project: data collection and packet metrics. 
The table below shows the risk of each of these challenges and what their mitigation strategies would be.
\begin{table}[H]        
\centering
\caption{Risks to the Project}
\begin{tabular}{ |p{4cm} ||p{4cm} |p{4cm} | p{4cm}| }\hline
\cellcolor{Black}\textcolor{White}{\textbf{Risk}}  & \cellcolor{Black}\textcolor{White}{\textbf{Description}} & \cellcolor{Black}\textcolor{White}{\textbf{Severity}} & \cellcolor{Black}\textcolor{White}{\textbf{Likelyhood}} & \cellcolor{Black}\textcolor{White}{\textbf{Mitigation}} \\ \hline
\multicolumn{5}{\cellcolor{Black}\textcolor{White}{\textbf{Data Collection}}} \\ \hline
Time to Collect Data & Is there enough time to collect the data required? & 2 & 2 & Start collecting data early in the project \\ \hline
Number of permutations of set ups & Are there enough different clock types and network layouts to be able to draw a conclusion from them? & 3 & 2 & Try as many combinations of clocks as possible. Start early \\ \hline
Hardware clock Failures & A hardware clock failing would push the project completion date back & 4 & 3 & Have software clocks on standby in case. Speak to Chronos if needed \\ \hline
Network Restrictions & Will the network be restricted? & 4 & 2 & Speak with BUCS ahead of time. \\ \hline
\multicolumn{5}{\cellcolor{Black}\textcolor{White}{\textbf{Packet Metrics}}} \\ \hline
Not enough Metrics & Not enough metrics to get a decent result & 2 & 1 & Research into other metrics. Speak to Chronos \\ \hline
Metrics not efficient & Implementation of metrics are not efficient & 2 & 3 & Start calculating metrics early \\ \hline
\end{tabular}
\end{table}

As it can be seen above the majority of the risks above relate to making sure that the project is started as early as possible and that both data collection and packet metric implementions can be worked on in parallel.

\section{Next Steps}

The next steps for the project can be split into a few distinct areas and these will be discussed in turn. The identified next steps for this project are: complete packet metrics, collect data, process the data using the metrics, and any other work.
The other work that might be included is cryptographically signing PTP packets. \\
\subsection{Complete Packet Metrics}

The plan for this section will be to finish implementing all of the packet metrics mentioned in the paper discussed previously \cite{ITUPacketMetrics}. 
These will be implemented fully and as efficiently as possible.
Most likely they will be split into incremental functions rather than the current method at the moment whereby the values are calculated fairly inefficiently.
This is important when larger datasets will be used.
Another method in resolving this would be to split the workload amongst multiple processes. 

\subsection{Data Collection}

Throughout the project more \ac{PTP} data will be collected. A range of sets of data will be taken, which include: different clock types, different clock locations, different times of day, different clock topologies. \\

The following tests will be performed:

\begin{itemize}
\item Chronos Grandmaster / Chronos Slave
\item Chronos Grandmaster / Software Slave
\item Chronos Grandmaster / Beaglebone Slave
\item Software Grandmaster / Chronos Slave
\item Software Grandmaster / Software Slave
\item Software Grandmaster / Beaglebone Slave
\end{itemize}

Each of the above will be tested in a few locations throughout the university and at different times of day.\\

An initial test on similarities between clock performances will be made.
If they end up being very similar, only one set up will be used. 
This can then be tested in different locations on the network.


\subsection{Data Processing}

Once data has been collected, it will be processed and analysed. For each set of data each metric will be computed. 
Note that one important step will be to understand what each metric does and what it means in terms of \ac{PTP} performance.
These metrics can then be compared against each other and plotted.
Other plotting techniques may also be used.
\section{Conclusion}

In conclusion, an introduction into this project has been given, with a list of the reports that were you read initially.
The work that has been completed thus far has been discussed with the next steps also broadly outlined.
Finally risks to the project have been identified and the next steps also highlighted.

\bibliographystyle{ieeetr}
\bibliography{Bibliography}
\begin{appendices}
\section{Gantt Table}
\begin{tabular}[H]
\begin{table}{|c|c|c|c|c|c|} \hline \\
 & Task Name & Duration & Start & Finish & Predecessors \\ \hline
A & \textbf{Deliverables} & 72 & Mon 03/02/14 & Tues 13/05/14 & \\ \hline
1 & Log Book & 65 & Mon 03/02/14 & Fri 02/05/14 & \\ \hline
2 & Interim Report & 9 & Fri 07/02/14 & Wed 19/02/14 & B, 1 \\ \hline
3 & Final Year Report & 17 & Mon 14/04/14 & Tues 06/05/14 & B,C,D,1,2 \\ \hline
4 & Poster & 5 & Wed 07/05/14 & Tues 13/05/14 & 1,3 \\ 3 \hline
B & \textbf{Preliminary Reading} & 7 & Mon 03/02/14 & Tues 11/02/14 & \\ \hline
1 & Read up on PTP & 7 & Mon 03/02/14 & Tues 11/02/14 & \\ \hline
2 & Reading about Metrics & 7 & Mon 03/02/14 & Tues 11/02/14 & \\ \hline
C & \textbf{Packet Metrics} & 35 & Mon 10/02/14 & Fri 28/03/14 & \\ \hline
1 & Decide on Language & 1 & Mon 10/02/14 & Mon 10/02/14 & \\ \hline
2 & Decide on Metrics & 1 & Mon 10/02/14 & Mon 10/02/14 & \\ \hline
3 & Implement Metrics & 24 & Mon 11/02/14 & 14/03/14 & 1,2 \\ \hline
4 & Test all Metrics & 33 & Wed 12/02/14 & Fri 27/03/14 & 3 \\ \hline
5 & Run some tests on sample Data & 8 & Wed 12/02/14 & Fri 21/02/14 & 3 \\ \hline 
D & \textbf{Data Collection} & 45 & Mon 03/02/14 & Fri 04/04/14 & \\ \hline
1 & Set up Equipment & 5 & Mon 03/02/14 & Fri 07/02/14 & \\ \hline
2 & Run Tests w/ Chronos Equipment & 10 & Mon 24/02/14 & Fri 07/03/14 & 1\\ \hline
3 & Run Tests w/ Software & 5 & Mon 10/03/14 & Fri 14/03/14 & 1 \\ \hline
4 & Run Tests with w/ Mix & 5 & Mon 17/03/14 & Fri 21/03/14 & 1 \\ \hline
5 & Other Tests & 10 & Mon 24/03/14 & 04/04/14 & 1 \\ \hline
6 & Run scripts on Results & 30 & Mon 24/02/14 & Fri 04/04/14 &  2,3,4,5 \\ \hline
E & Other Work and Buffer & 5 days & Mon 07/04/14 & 11/04/14 & \\ \hline
\end{table}
\end{tabular}
\section{Gantt Chart}
\begin{figure}
\centering
\includegraphics[angle=90][scale=0.6]{./Figures/Ganttchart.eps}
\caption{Gantt Chart}
\end{figure}

\section{TDEV Script}
\begin{lstlisting}
#!/usr/bin/env Rscript
#-----------------------------------------------------
#-----------------------------------------------------
#--                Function Name: TDEV              --
#--                Name: Time Deviation             --
#--           Input: nTo - position in list         --
#--                  N   - number of samples        -- 
#--                  x   - vector of samples        --
#--           Output : time deviation               --
#-----------------------------------------------------
#-----------------------------------------------------
TDEV <- function(To,n, N,x){
#	To <- 0.1 #time between samples
#	n <- nTo / To #number of samples to current point
	window <- 5 # Set window Size
	windowSide <- (window - 1) / 2 # Set the length of Side of window
	outerStep <- 0 
	for (j in windowSide+1:(N-3*n + 1) - windowSide){
		interimStep <- 0
		for (i in j:(n+j - 1)){
			interimStep <- interimStep + mean(x[(i + (2*n)) - windowSide:(i + (2*n)) + windowSide]) - 2* mean(x[i+n - windowSide : i + n + windowSide]) + mean(x[i - windowSide : i + windowSide])
		}
		interimStep = interimStep ^ 2
		outerStep = outerStep + interimStep
	}
	outerStep = outerStep / (6 * (N - (3*n) + 1));
	result <- sqrt(outerStep)
	return(result) 
}
\end{lstlisting}

\section{minTDEV Script}
\begin{lstlisting}
#!/usr/bin/env Rscript
#-----------------------------------------------------
#-----------------------------------------------------
#--                Function Name: minTDEV           --
#--                Name: Minimum Time Deviation     --
#--           Input: nTo - position in list         --
#--                  N   - number of samples        -- 
#--                  x   - vector of samples        --
#--           Output : time deviation               --
#-----------------------------------------------------
#-----------------------------------------------------
minTDEV <- function(To,n, N,x){
#	To <- 0.1 #time between samples
#	n <- nTo / To #number of samples to current point
	window <- 5 # Set window Size
	windowSide <- (window - 1) / 2 # Set the length of Side of window
	outerStep <- 0 
	for (j in windowSide+1:(N-3*n + 1) - windowSide){
		interimStep <- 0
		for (i in j:(n+j - 1)){
			interimStep <- interimStep + min(x[(i + (2*n)) - windowSide:(i + (2*n)) + windowSide]) - 2* min(x[i+n - windowSide : i + n + windowSide]) + min(x[i - windowSide : i + windowSide])
		}
		interimStep = interimStep ^ 2
		outerStep = outerStep + interimStep
	}
	outerStep = outerStep / (6 * (N - (3*n) + 1));
	result <- sqrt(outerStep)
	return(result) 
}


\end{lstlisting}
\section{bandMean Scriot}
\begin{lstlisting}
#!/usr/bin/env Rscript
#-----------------------------------------------------
#-----------------------------------------------------
#--                Function Name: bandMean          --
#--                Name: Band Mean                  --
#--           Input: window - the samples           --
#--                     a   - lower band            -- 
#--                     b   - upper band            --
#--           Output : mean of window               --
#-----------------------------------------------------
#-----------------------------------------------------
bandMean <- function(window,a,b){
	sum = 0
	for (i in a:b){
		sum = sum + window(i) # sum window from a to b
	}
	average = sum / (b - a + 1)
	return (average)
}
\end{lstlisting}

\section{bandTDEV Script}
\begin{lstlisting}
#!/usr/bin/env Rscript

#-----------------------------------------------------
#-----------------------------------------------------
#--              Function Name: bandTDEV            --
#--             Name: band Time Deviation           --
#--        Input: nTo - position in list            --
#--                N   - number of samples          -- 
#--                x   - vector of samples          --
#--       Output : band time deviation              --
#-----------------------------------------------------
source("bandMean.r")

bandTDEV <- function(nTo,N,x){
	To <- 0.1 # set minimum step
	n <- nTo / To #number of samples to current
	window <- 15
	windowStep <- (window - 1) / 2 #set side of window
	outerStep <- 0
	a <- 20
	b <- 80
	for (j in 1:(N-3*n + 1)){
		interimStep <- 0
		for (i in j:(n+j - 1)){
			interimStep <- interimStep + bandMean(x[i + 2*n - windowStep : i + 2*n + windowStep],a,b) - 2 * bandMean(x[i+n - windowStep : i + n + windowStep],a,b) + bandMean(x[i - windowStep : i + windowStep],a,b) 
		}
		interimStep = interimStep ^ 2
		outerStep = outerStep + interimStep
	}
	outerStep = outerStep / (6 * (N - 3*n + 1))
	result <- sqrt(outerStep)
	return(result) 
}
\end{lstlisting}
\section{Packet Metric Script}
\begin{lstlisting}
#!/usr/bin/env Rscript

# ----------------------------------------------------
# -         Script Name: PacketMetric.r              -
# -       Description: This script will calculate    -
# -       the packet metrics for the given data set. -
# ----------------------------------------------------

source("TDEV.r") #Import TDEV Script
source("minTDEV.r") #Imprt MinTDEV Script
#---------- Import Data into script -----------
arguments  <- commandArgs()
sampleSize <- arguments[6] #Command line args start from index 6

fileName = paste("../PTPData/TestData/SampleSize_", sampleSize, ".txt",sep="")
print(fileName)

print ("Reading CSV Data...")
Data <- read.csv(file = fileName,head = TRUE, sep=",")
print ("CSV Data has been written to Data variable")
delays <- as.matrix(Data[4])
# delays <-sort(delays) Sort if needed
To <- 1/16 #Assume To = 1/16
# ---- Removes Init Messages and the first value
delays = delays[-1] 
delays = delays[-1]
delays = delays[-1]
#print (delays)
N <- as.numeric(sampleSize) - 4 #1 for the header, 2 for init, and 1 for the null value

maxn = floor(N / 3)

resultTDEV = matrix(0,maxn)
resultMinTDEV = matrix(0,maxn)

for (i in 1:maxn){
	
	resultTDEV[i] <- TDEV(To,i,N,delays)
	resultMinTDEV[i] <-minTDEV(To,i,N,delays)
}

#print(resultMinTDEV)
rangeOfValues <- range(0,resultTDEV,resultMinTDEV)
print(rangeOfValues)
#Name pdf file..
outputFileName = paste("../PTPData/Plots/Packet Results - Sample Size - ",N,".eps",sep = "")
setEPS()
postscript(outputFileName)
plot(resultMinTDEV,type="o", col="red",log="xy")
lines(resultTDEV,type="o",col="blue")
legend(1,rangeOfValues[2],c("TDEV", "minTDEV"), cex = 0.8,col=c("blue","red"), pch=21:22, lty=1:2)

dev.off()


\end{lstlisting}
\section{Table for a sample size of 500}

\end{appendices}
\end{document}

